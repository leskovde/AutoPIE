%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{beamer}
\usetheme[faculty=econ]{fibeamer}
\usepackage[utf8]{inputenc}
\usepackage[
  main=english, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the
                %% presentation in either Czech or Slovak,
                %% respectively.
  czech, slovak %% The additional keys allow foreign texts to be
]{babel}        %% typeset as follows:
%%
%%   \begin{otherlanguage}{czech}   ... \end{otherlanguage}
%%   \begin{otherlanguage}{slovak}  ... \end{otherlanguage}
%%
%% These macros specify information about the presentation
\title{Automated Program Minimization \protect\\ With Preservation of Runtime Errors} %% that will be typeset on the
\subtitle{Thesis Defense} %% title page.
\author{Denis Leskovar}
%% These additional packages are used within the document:
\usepackage{ragged2e}  % `\justifying` text
\usepackage{booktabs}  % Tables
\usepackage{tabularx}
\usepackage{tikz}      % Diagrams
\usetikzlibrary{calc, shapes, backgrounds}
\usepackage{amsmath, amssymb}
\usepackage{url}       % `\url`s
\usepackage{listings}  % Code listings
\frenchspacing
\begin{document}
  \shorthandoff{-}
  \frame[c]{\maketitle}

\begin{frame}{Outline}
    \tableofcontents[]
\end{frame}

\section{Problem description}

    \begin{frame}{Problem description}
      \framesubtitle{Automating parts of the debugging process}
      Debugging remains a mostly manual chore.\\
      \begin{itemize}
          \item The developer has to look for a root cause of an error.\\
          \item He then has to create an appropriate fix.\\
      \end{itemize}
      
      \bigskip

      We can speed up the first step by reducing the source code size.\\
      
      \bigskip
      \bigskip
      
      The \alert{reduction} can be \alert{automated}.
    \end{frame}

    \begin{frame}{Problem description}
      \framesubtitle{Reducing source code to \alert{minimal} error-inducing code snippets}
      Reduced and minimal source code variants.

      \begin{block}{A reduced variant}
        Smaller in size compared to the original, contains the error-inducing statement.
      \end{block}
      \begin{block}{A minimal variant}
        The \alert{smallest} executable error-inducing \alert{subset} of the original source code.
      \end{block}
      \begin{alertblock}{Time complexity}
        A reduced variant can be approximated in polynomial time. However, the minimal variant can only be extracted in $O(2^n)$.
      \end{alertblock}
    \end{frame}


\section{Employed approaches}

    \begin{frame}{Comparing different approaches}
      Existing techniques can be employed to achieve the optimal results.\\
      \begin{itemize}
          \item \alert{Delta debugging} approximates the minimal source code subset.\\
          \item \alert{Static slicing} efficiently removes unnecessary code.\\
          \item \alert{Dynamic slicing} provides the minimal slice.\\
      \end{itemize}
    
      \bigskip
      Generated reduced program variants are \alert{validated}: compiled and tested at runtime.\\
      \bigskip
      A combination of the existing techniques helps eliminate the shortcomings of each individual one.\\
      \bigskip
      
      The highlighted techniques were implemented and benchmarked.
    \end{frame}


\section{Results}

    \begin{frame}{Results}
      \framesubtitle{Benchmark setup}
      
      \begin{block}{Hypothesis}
        A pipeline of multiple techniques achieves the optimal result in reasonable time (compared to the exponential algorithm).
      \end{block}
      
      The pipeline performs the following steps.
      
      \begin{enumerate}
          \item The \alert{static slicer} removes dead code.\\
          \item The \alert{dynamic slicer} extracts the minimal slice.\\
          \item The \alert{$dd_{min}$ algorithm} finds a local minimum.\\
          \item The \alert{naive reduction} finds the global minimum.\\
      \end{enumerate}
      
    \end{frame}

    \begin{frame}{Results}
      \framesubtitle{Benchmark results - distance to the optimal result}
      \begin{table}[!b]
        {\carlitoTLF % Use monospaced lining figures
        \begin{tabularx}{\textwidth}{lccc}
          \textbf{Statements} & \textbf{N. R. (\%)} & \textbf{DD R. (\%)} &
          \textbf{P. R. (\%)} \\
          \toprule
          $2^{20}$       & 0.0  & 0.0  &
          0.0 \\% t.1
          $2^{25}$           & 0.0     & 28.4  &
          0.0 \\% t.3
          $2^{29}$    & 0.0      & 28.4  &
          0.0  \\% t.9
          $2^{31}$              & 3.7      & 5.9 &
          0.8  \\% t.11
          $2^{40}$          & 0.0       & 42.5  &
          0.0  \\% t.14
          $2^{49}$               & 51.7      & 45.7  &
          45.7  \\% t.28
          $2^{65}$         & 58.0      & 51.0  &
          50.1  \\% t.29
          \bottomrule
        \end{tabularx}}
        \caption{Selected test cases, each has 50-150 lines of C/C++ source code. \newline 
        The percentages in the last three columns correspond to the distance of the generated reduced variant to the actual optimal solution.}
      \end{table}
    \end{frame}
    
    \begin{frame}{Results}
      \framesubtitle{Benchmark results - running time}
      \begin{table}[!b]
        {\carlitoTLF % Use monospaced lining figures
        \begin{tabularx}{\textwidth}{lrrr}
          \textbf{Statements} & \textbf{N. R. (s)} & \textbf{DD R. (s)} &
          \textbf{P. R. (s)} \\
          \toprule
          $2^{20}$       & 3.4  & 11.2  &
          14.7 \\% t.1
          $2^{25}$           & 589.7     & 13.6  &
          135.0 \\% t.3
          $2^{29}$    & 296.1      & 16.0  &
          79.2  \\% t.9
          $2^{31}$              & 186.6      & 18.4 &
          60.3  \\% t.11
          $2^{40}$          & 914.6       & 23.5  &
          212.3  \\% t.14
          $2^{49}$               & 7662.5      & 28.0  &
          1569.8  \\% t.28
          $2^{65}$         & 1135.4      & 30.0  &
          2773.7  \\% t.29
          \bottomrule
        \end{tabularx}}
        \caption{Selected test cases, each has 50-150 lines of C/C++ source code. \newline 
        Each last three columns show the running time of the three compared methods in seconds.}
      \end{table}
    \end{frame}
    
    
\section{Summary}
    
    \begin{frame}{Summary}
      We have presented the following.\\
      \begin{itemize}
          \item Exponential algorithms are required for optimal program minimization.\\
          \item We can reduce the search space by employing existing techniques.\\
          \item Polynomial algorithms help remove dead code, thus reducing the input size.\\
          \item We determine the correctness of a variant at runtime.\\
          \item Our hypothesis is valid on a sample of small programs.\\
      \end{itemize}
      
    \end{frame}

\end{document}
