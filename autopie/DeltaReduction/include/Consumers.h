#ifndef CONSUMERS_DELTA_H
#define CONSUMERS_DELTA_H
#pragma once

#include <clang/AST/ASTConsumer.h>

#include <utility>

#include "Visitors.h"
#include "../../Common/include/Context.h"
#include "../../Common/include/DependencyGraph.h"
#include "../../Common/include/Visitors.h"
#include "../../Common/include/Streams.h"
#include "../../Common/include/Consumers.h"
#include "../../Common/include/Helper.h"

namespace Delta
{
	/**
	 * Prepares and dispatches the `DeltaIterationASTVisitor`, prints its output.\n
	 * Serves as a middle man for data transactions.
	 */
	class DeltaIterationASTConsumer final : public clang::ASTConsumer
	{
		VariantPrintingASTVisitorRef visitor_;

	public:
		explicit DeltaIterationASTConsumer(clang::CompilerInstance* ci, int errorLine) : visitor_(std::make_unique<DeltaIterationASTVisitor>(ci, errorLine))
		{
		}

		/**
		 * Dispatches the visitor to the root node.\n
		 * The visitor is fed with input data and output references so that the output can be extracted after the AST pass.\n
		 * A variant is generated based on the input bitmask.\n
		 * The generated variant is dumped to the specified file.
		 *
		 * @param context The AST context.
		 * @param fileName The file to which the output should be written.
		 * @param bitMask The specification of which nodes should be kept and which should be removed.
		 */
		void HandleTranslationUnit(clang::ASTContext& context, const std::string& fileName, const BitMask& bitMask) const
		{
			auto rewriter = std::make_shared<clang::Rewriter>(context.getSourceManager(), context.getLangOpts());

			visitor_->Reset(bitMask, rewriter);
			visitor_->TraverseDecl(context.getTranslationUnitDecl());

			out::Verb() << "Variant after iteration:\n";

			if (Verbose)
			{
				rewriter->getEditBuffer(context.getSourceManager().getMainFileID()).write(llvm::errs());

			}
			out::Verb() << "\n";

			std::error_code errorCode;
			llvm::raw_fd_ostream outFile(fileName, errorCode, llvm::sys::fs::F_None);

			rewriter->getEditBuffer(context.getSourceManager().getMainFileID()).write(outFile);
			outFile.close();
		}

		/**
		 * Passed instances of members that could not be initialized previously to the visitor.
		 *
		 * @param skippedNodes A container of nodes that should be skipped during the traversal generated by the `MappingVisitor`.
		 * @param graph The node dependency graph generated by the `MappingVisitor`.
		 */
		void SetData(SkippedMapRef skippedNodes, DependencyGraph graph) const
		{
			visitor_->SetData(std::move(skippedNodes), graph);
		}

		/**
		 * After the visitor's traversal is complete, the error-inducing line number is updated.
		 *
		 * @return The new presumed line on which the error should be thrown.
		 */
		int GetAdjustedErrorLine() const
		{
			return visitor_->AdjustedErrorLine;
		}
	};

	/**
	 * Unifies other consumers and uses them to describe the Delta debugging logic.\n
	 * Single `HandleTranslationUnit` manages one run of the Delta debugging algorithm.
	 */
	class DeltaDebuggingConsumer final : public clang::ASTConsumer
	{
		DependencyMappingASTConsumer mappingConsumer_;
		DeltaIterationASTConsumer iterationConsumer_;
		GlobalContext& globalContext_;

	public:
		DeltaDebuggingConsumer(clang::CompilerInstance* ci, GlobalContext& context) : mappingConsumer_(ci, context),
			iterationConsumer_(ci, context.parsedInput.errorLocation.lineNumber),
			globalContext_(context)
		{
		}

		/**
		 * Runs two consumer steps to generate all possible variants.\n
		 * Firstly, a mapping consumer is called to analyze AST nodes and create a traversal order.\n
		 * Secondly, a bitmask based on the number of found code units is created.
		 * Each bit in the bitmask represents a node based on the traversal order.
		 * Setting a bit to true translates to the corresponding node being present in the output.
		 * Setting a bit to false results in the deletion of the corresponding node.\n
		 * Lastly, all possible bitmask variants are generated and the variant printing consumer is called
		 * for each bitmask variant.
		 *
		 * @param context The AST context.
		 */
		void HandleTranslationUnit(clang::ASTContext& context) override
		{
			mappingConsumer_.HandleTranslationUnit(context);
			const auto numberOfCodeUnits = mappingConsumer_.GetCodeUnitsCount();

			globalContext_.variantAdjustedErrorLocation.clear();
			iterationConsumer_.SetData(mappingConsumer_.GetSkippedNodes(), mappingConsumer_.GetDependencyGraph());

			auto dependencies = mappingConsumer_.GetDependencyGraph();

			auto binCount = 2;
			
			auto iteration = 0;
			const auto cutOffLimit = 0xffff;

			while (iteration < cutOffLimit)
			{
				iteration++;

				if (iteration % 50 == 0)
				{
					out::All() << "Done " << iteration << " DD iterations.\n";
				}

				// 1. Split into a container of equal sized bins.
				// 2. Get a container of complements.
				// 3. Loop over the first container and test each bin (generate variant and execute).
				// 4. If a variant fails, set n to 2 and the file to that variant.
				// 5. Loop over the second container and test --||--.
				// 6. If a variant fails, decrement n and set the file to that variant/
				// 7. If nothing fails, set n to 2 *n.
				
				try
				{
					auto fileName = TempFolder + std::to_string(iteration) + "_" + GetFileName(globalContext_.parsedInput.errorLocation.filePath) + LanguageToExtension(globalContext_.language);
					iterationConsumer_.HandleTranslationUnit(context, fileName);

					globalContext_.variantAdjustedErrorLocation[iteration] = iterationConsumer_.GetAdjustedErrorLine();
				}
				catch (...)
				{
					out::All() << "Could not process iteration no. " << iteration << " due to an internal exception.\n";
				}
			}

			out::All() << "Finished. Done " << iteration << " DD iterations.\n";
		}
	};
}

#endif