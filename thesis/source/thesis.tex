%%% The main file. It contains definitions of basic parameters and includes all other parts.

%% Settings for single-side (simplex) printing
% Margins: left 40mm, right 25mm, top and bottom 25mm
% (but beware, LaTeX adds 1in implicitly)
\documentclass[12pt,a4paper]{report}
\setlength\textwidth{145mm}
\setlength\textheight{247mm}
\setlength\oddsidemargin{15mm}
\setlength\evensidemargin{15mm}
\setlength\topmargin{0mm}
\setlength\headsep{0mm}
\setlength\headheight{0mm}
% \openright makes the following text appear on a right-hand page
\let\openright=\clearpage

%% Settings for two-sided (duplex) printing
% \documentclass[12pt,a4paper,twoside,openright]{report}
% \setlength\textwidth{145mm}
% \setlength\textheight{247mm}
% \setlength\oddsidemargin{14.2mm}
% \setlength\evensidemargin{0mm}
% \setlength\topmargin{0mm}
% \setlength\headsep{0mm}
% \setlength\headheight{0mm}
% \let\openright=\cleardoublepage

%% Generate PDF/A-2u
\usepackage[a-2u]{pdfx}

%% Character encoding: usually latin2, cp1250 or utf8:
\usepackage[utf8]{inputenc}

%% Prefer Latin Modern fonts
\usepackage{lmodern}

%% Further useful packages (included in most LaTeX distributions)
\usepackage{amsmath}        % extensions for typesetting of math
\usepackage{amsfonts}       % math fonts
\usepackage{amsthm}         % theorems, definitions, etc.
\usepackage{bbding}         % various symbols (squares, asterisks, scissors, ...)
\usepackage{bm}             % boldface symbols (\bm)
\usepackage{graphicx}       % embedding of pictures
\usepackage{fancyvrb}       % improved verbatim environment
\usepackage[numbers]{natbib}         % citation style AUTHOR (YEAR), or AUTHOR [NUMBER]

%%% !!! Citation style is overriden to just a [NUMBER] !!!

\usepackage[nottoc]{tocbibind} % makes sure that bibliography and the lists
			    % of figures/tables are included in the table
			    % of contents
\usepackage{dcolumn}        % improved alignment of table columns
\usepackage{booktabs}       % improved horizontal lines in tables
\usepackage{paralist}       % improved enumerate and itemize
\usepackage{xcolor}         % typesetting in color

%% Path to images
\graphicspath{ {../img/} }

%%% Basic information on the thesis

% Thesis title in English (exactly as in the formal assignment)
\def\ThesisTitle{Automated Program Minimization With Preserving of Runtime Errors}

% Author of the thesis
\def\ThesisAuthor{Denis Leskovar}

% Year when the thesis is submitted
\def\YearSubmitted{2021}

% Name of the department or institute, where the work was officially assigned
% (according to the Organizational Structure of MFF UK in English,
% or a full name of a department outside MFF)
\def\Department{Department of Distributed and Dependable Systems}

% Is it a department (katedra), or an institute (ústav)?
\def\DeptType{Department}

% Thesis supervisor: name, surname and titles
\def\Supervisor{doc. RNDr. Pavel Parízek, Ph.D.}

% Supervisor's department (again according to Organizational structure of MFF)
\def\SupervisorsDepartment{Department of Distributed and Dependable Systems}

% Study programme and specialization
\def\StudyProgramme{Computer Science}
\def\StudyBranch{System Programming}

% An optional dedication: you can thank whomever you wish (your supervisor,
% consultant, a person who lent the software, etc.)
\def\Dedication{%
Dedication.
}

% Abstract (recommended length around 80-200 words; this is not a copy of your thesis assignment!)
\def\Abstract{%
Debugging large programs is a complex and time-consuming task, which has not 
been fully automated yet. 
Given a runtime error, the developer must first reproduce it. 
He then has to find the root cause of the error and create a proper bug fix. 
Automation can make this process significantly more efficient by reducing 
the amount of code the developer has to look through. 
This thesis introduces three methodologies of automatically reducing a given 
failing program into its minimal runnable subset. 
The techniques are based on existing findings in the field of debugging. 
The automatically minimized program must result in the same runtime error 
as the original program. 
The minimization focuses on optimal results in a domain of small and simple 
applications. 

The goal of this thesis is to discuss techniques that are practical for 
program reduction. 
These techniques are implemented using Clang LibTooling, a library for 
standalone Clang tools. 
The inner workings of each implementation are explained, and their limitations 
are exposed. 
The implementations are benchmarked on a set of C and C++ source files.  
Performance is measured based on the size of the generated output and 
the running time of the algorithm.
}

% 3 to 5 keywords (recommended), each enclosed in curly braces
\def\Keywords{%
{automated debugging}, {code analysis}, {syntax tree}, {statement reduction}, {clang libtooling}
}

%% The hyperref package for clickable links in PDF and also for storing
%% metadata to PDF (including the table of contents).
%% Most settings are pre-set by the pdfx package.
\hypersetup{unicode}
\hypersetup{breaklinks=true}

% Definitions of macros (see description inside)
\include{macros}

% Title page and various mandatory informational pages
\begin{document}
\include{title}

%%% A page with automatically generated table of contents of the bachelor thesis

\tableofcontents

%%% Each chapter is kept in a separate file
\include{preface}
\include{chap01_debugging}
\include{chap02_tools}
\include{chap03_clang}
\include{chap04_minimization}
\include{chap05_implementation}
\include{chap06_evaluation}

\include{epilog}

%%% Bibliography
\include{bibliography}

%%% Figures used in the thesis (consider if this is needed)
\listoffigures

%%% Tables used in the thesis (consider if this is needed)
%%% In mathematical theses, it could be better to move the list of tables to the beginning of the thesis.
\listoftables

%%% Abbreviations used in the thesis, if any, including their explanation
%%% In mathematical theses, it could be better to move the list of abbreviations to the beginning of the thesis.
\chapwithtoc{List of Abbreviations}

%%% Attachments to the bachelor thesis, if any. Each attachment must be
%%% referred to at least once from the text of the thesis. Attachments
%%% are numbered.
%%%
%%% The printed version should preferably contain attachments, which can be
%%% read (additional tables and charts, supplementary text, examples of
%%% program output, etc.). The electronic version is more suited for attachments
%%% which will likely be used in an electronic form rather than read (program
%%% source code, data files, interactive charts, etc.). Electronic attachments
%%% should be uploaded to SIS and optionally also included in the thesis on a~CD/DVD.
%%% Allowed file formats are specified in provision of the rector no. 72/2017.
\appendix
\chapter{Attachments}

\section{Content of the attachment}
\dirtree{%
.1 Attachment{.zip}.
.2 AutoPie.
.3 Common \DTcomment{Source code shared by multiple projects.}.
.4 include.
.4 src.
.4 Makefile.
.3 DeltaReduction \DTcomment{Delta debugging algorithm's project directory.}.
.4 docs.
.4 include.
.4 src.
.4 Makefile.
.4 evaluate{.sh}.
.3 docs \DTcomment{Main documentation output path.}.
.3 EvaluationData \DTcomment{Evaluation dataset.}.
.3 NaiveReduction \DTcomment{Project directory of the naive approach.}.
.4 docs.
.4 include.
.4 src.
.4 Makefile.
.4 evaluate{.sh}.
.3 Scripts \DTcomment{Slicing-related components.}.
.4 SlicingReduction{.py} \DTcomment{Slicing-based minimization script.}.
.4 evaluate{.sh}.
.4 slice{.py}.
.4 unify{.py}.
.3 SliceExtractor \DTcomment{Slice-processing helper utility.}.
.4 docs.
.4 include.
.4 src.
.4 Makefile.
.3 VariableExtractor \DTcomment{Slice-preprocessing utility}.
.4 docs.
.4 src.
.4 Makefile.
.3 Makefile \DTcomment{Master Makefile that builds all components.}.
.3 buildLLVM{.sh} \DTcomment{Setup script for building LLVM.}.
}

The attachment is also available through an online repository. 
The repository can be found at \url{https://github.com/leskovde/AutoPIE}.

\section{User Documentation}

\subsection{System requirements}

The target system has to build AutoPIE, LLVM, Clang, and LLDB as well. 
Building the LLVM project utilizes a large number of system resources.  
In order to build the project correctly, the system must meet the following 
requirements:
\begin{itemize}
  \item The system must have at least 8 GB of memory.
  \item The system must have an x86-based CPU.
  \item The system should have at least 5 GB of free disk space and 
  optionally up to 40 GB of disk space for the debug build.
  \item The system must run a Linux distribution supported by LLVM 11.0.0.
\end{itemize}

Any mainstream Linux distributions released in the year 2020 and later are 
supported, provided they can run the tools specified in the following 
section. 
This list includes, for example, Manjaro 21.0, Arch Linux 2020.06.01, and 
Ubuntu 20.04.

\subsection{Prerequisites}

In order to build and launch AutoPIE, one must first install all underlying 
tools, libraries, and frameworks. 
The following list contains all tools and utilities that are required to 
build and run the project.

\begin{itemize}
  \item python2
  \item python3
  \item python-dev
  \item libedit-dev
  \item cmake
  \item ninja-build
  \item make
  \item gcc
  \item zlib
  \item coreutils
  \item graphviz
  \item docker
  \item docker-py
  \item swig
  \item doxygen
\end{itemize}

Additionally, the user must have the following packages available in their 
Python interpreter:

\begin{itemize}
  \item docker
  \item argparse
  \item shutil
  \item pathlib
\end{itemize}

Once these requirements are met, the user can proceed to build LLVM, Clang, 
and LLDB. 
The building process is lengthy, complex, and tedious. 
Therefore, we have created a script that automizes the process. 
The build can be launched by following the described steps.

\begin{enumerate}
  \item Navigate to the \icode{AutoPie} directory.
  \item Use \icode{chmod +x ./buildLLVM.sh} to give the script required 
  permissions.
  \item Run the script as root using \icode{sudo ./buildLLVM.sh}.
\end{enumerate}

The build script performs the following steps:

\begin{enumerate}
  \item It downloads the required version of the LLVM from the official 
  GitHub repository. 
  The specific version for this project is 11.0.0.
  \item It extracts the downloaded archive into a temporary directory.
  \item It creates a build subdirectory in the temporary path and navigates 
  to it.
  \item It executes the CMake command, which prepares the build 
  configuration for the required projects. 
  Notably, the Clang and LLVM projects are configured in x86 Release mode 
  with libraries and scripting support.
  \item It launches the Ninja tool, which builds the LLVM project. 
  It then installs the necessary headers and libraries into system paths.
  \item It exports the linker library path, which now contains 
  \icode{/usr/local/lib/}. 
  This export expires once the current shell is terminated.
\end{enumerate}

Confirm that the installation has finished correctly by checking the output 
of \icode{ls /usr/local/lib}. 
If the output contains libraries starting with \icode{libLLVM} and 
\icode{libclang}, the installation script has most likely performed all of 
its actions correctly. 
The linker now needs to know where to find the shared libraries. 
The user needs to ensure that the \icode{LD\_LIBRARY\_PATH} variable contains 
the path to \icode{/usr/local/lib}. 
In case it does not, the path can be added by executing the following command:

\icode{export LD\_LIBRARY\_PATH=\$LD\_LIBRARY\_PATH:/usr/local/lib/}.

If successful, the user can now use LLVM libraries when linking C++ projects.

\subsection{Building AutoPIE}

The project consists of several C++ binaries. 
These binaries can be built using makefiles in their respective directories. 
The \icode{AutoPie} directory also contains a \icode{Makefile} that builds 
all the projects. 
Once built, the binaries can be found in the following directories:
\icode{NaiveReduction} is available under 
\icode{AutoPie\-/NaiveReduction\-/build\-/bin\-/NaiveReduction}.
\icode{DeltaReduction} can be found under 
\icode{AutoPie\-/DeltaReduction\-/build\-/bin\-/DeltaReduction}.
The helper utilities \icode{VariableExtractor} and \icode{SliceExtractor} can 
be found in 
\icode{AutoPie\-/Vari\-ableExtractor\-/build\-/bin\-/VariableExtractor} 
and \icode{AutoPie\-/Slice\-Extract\-or/build\-/bin\-/Slice\-Extractor} 
respectivelly.

The slicing-based approach does not need to be built since it is implemented 
in Python. 
However, it utilizes all four mentioned C++ projects. 
Those must be present in order for the Python script to work correctly.

\subsection{Building documentation}

AutoPIE is extensively documented in its source code. 
We are aware of the fact that skimming through source code is not convenient 
for the user. 
Therefore we have created a Doxygen target for every \icode{Makefile} in 
the project. 
The user, with installed Doxygen, can build the documentation for individual 
components by navigating to their directories and using 
the \icode{make docs} command. 
The documentation is generated to the \icode{docs} directory in 
the component's subfolder as HTML or \LaTeX~files.

A more comprehensive way of using the generated documentation is by invoking
\icode{make docs} in the \icode{AutoPie} directory. 
This target generates the documentation of the entire project, include all 
of its components. 
The documentation is available in the \icode{AutoPie/docs} directory in both 
the HTML and \LaTeX~form.

It should be noted once again that the requirement for building 
the documentation is the Doxygen package.

\subsection{Running AutoPIE}

The user can execute the three approaches as follows:

\begin{itemize}
  \item The naive approach can be launched by executing 
  the \icode{NaiveReduction} program built from the earlier steps.
  \item The minimizing Delta debugging algorithm can be launched by 
  executing the \icode{DeltaReduction} program built from the earlier steps.
  \item The slicing-based approach can be launched by running 
  \icode{cd AutoPie\-/Scri\-pts\- \&\& python3 ./SlicingReduction.py}, 
  having built all other projects from the earlier steps.
\end{itemize}

Each project's required and supported arguments can be viewed using 
the \icode{--help} option available for each program and script.

The user can run the evaluation dataset by navigating to a subdirectory of 
an approach and launching \icode{evaluate.sh}. 

For example: \icode{cd autopie/NaiveReduction \&\& make \&\& ./evaluate.sh}.

When trying to run any component, the user might encounter an error while 
loading shared libraries. 
This error might stem from the fact that the installation script has not 
ended successfully, and therefore, \icode{/usr/local/lib} does not contain 
the necessary libraries. 
However, the more likely option is that the \icode{LD\_LIBRARY\_PATH} variable 
does not contain the proper path. 

The user can fix that by executing the following command:

\icode{export LD\_LIBRARY\_PATH=\$LD\_LIBRARY\_PATH:/usr/local/lib/}.

\openright
\end{document}
