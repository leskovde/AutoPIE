\chapter{Clang LibTooling}\label{chap:libtooling}

The previous chapter described tools and environments that were taken
into consideration for this project. 
The utmost importance was given to the~ease of~use, availability, and 
active community. 
As the~reader might have guessed from the~summary, the~LLVM/Clang 
suite stood out as the~best candidate.

Clang is a~language front-end. With high compilation performance, 
low memory footprint, and modifiable code base, it quickly and flexibly 
converts source code to LLVM intermediate code representation. 
The front-end supports languages and frameworks such as C/C++, 
Objective C/C++, CUDA, OpenCL, OpenMP, RenderScript, and HIP. 
This support is crucial for this thesis since the~project 
aims to support both C and C++. 
The LLVM Core then handles the~optimization and IR synthesis, 
supporting a~plethora of~popular CPUs.

Clang is widely used for its warnings and error checks, both very 
helpful and outstanding compared to competing compilers. 
Furthermore, Clang offers an extensive tooling infrastructure 
through which tools such as clang-tidy were developed. 
A relatively well-documented tooling API written in~C++ helps 
programmers create their tools easily. 
However, not all developers share the~same skill set. 
Some programmers require complicated additional features, while others 
prefer an easy-to-use interface. 
The tooling API has been split into multiple libraries and frameworks,
including Plugins and LibClang.
Explaining the two mentioned libraries is necessary. 
It is essential to show their capabilities before introducing LibTooling. 
LibTooling is the tooling library ultimately chosen for this project.

\paragraph{Plugins.}

The~library intuitively called Plugins is used for plugin development.
The library is linked dynamically, resulting in~relatively small tools.
Plugins are launched at compilation and offer compilation control as well 
as access to the~AST.

More specifically, Plugins allow performing an extra custom front-end action 
during compilation.
The functionality is generally similar to that of~LibTooling, which will be 
talked about later.
However, unlike a~standalone tool, Plugins cannot do any tasks before and after 
the analysis (and compilation).
When creating a~plugin, one can choose from a~selection of~
\icode{FrontendAction} classes to inherit.
If, for example, the~plugin should work with the~AST, 
the \icode{ASTFrontendAction} can be inherited.
Doing so also allows overriding the~\icode{ParseArgs} method, in~which 
the plugin's command line handling is specified.

Due to dynamic loading, the~wanted plugin must be added to a~plugin registry 
inside the~code.
The plugin is then loaded from the~registry by specifying the~\icode{-load} 
command or \icode{-fplugin} on the~command line when running clang.
The plugin takes those arguments from the~command line that are prefixed 
by \icode{-Xclang}.

\paragraph{LibClang.}

Another framework, LibClang, offers a~simple C and Python API for quick 
tool writing. 
Unlike Plugins and LibTooling, which will be mentioned later, the~code 
base of~LibClang is stable. 
This stability implies that tools written using LibClang do not require
upkeep with every new LLVM/Clang release. 
Overall, the~framework and tools written using it are high-level and 
are easily readable.

\paragraph{LibTooling.}

The most feature woven set of~libraries is LibTooling. 
Unlike Plugins, LibTooling \citep{libtooling:online} 
allows the~developer to build standalone 
Clang tools. 
This robust framework is written in~C++ and has an active 
community of~contributors. 
One can find many manuals and tutorials online. 
However, with each contribution to LibTooling and each release of~Clang, 
there is a~chance that older tools will not support the~newer LibTooling 
API. 
That is the~reason why countless tools written using this framework do not
run in~modern environments. 
Programmers who use LibTooling cannot expect compatibility in~upcoming 
releases. 
On the~bright side, the~libraries of~LibTooling allow a~plethora of~source
code modifications, AST traversals, and access to the~compiler's internals.

The set of~features supplied by LibTooling is immense. 
The following sections describe notable features used during 
the implementation of~this project. 
The reader should get a~better idea of~how a~tool is built and what 
LibTooling offers during the~development process. 
Important concepts, such as providing the~correct input to the~tool 
in the~form of~a~compilation database, traversing the~AST, 
and modifying source code inside the~tooling environment, 
are described below. 
These concepts will be referenced further in~the text.

\section{Compilation databases}

To accurately and faithfully recreate a~compilation, tools created using 
LibTooling require a~compilation database (CD) \citep{cd:online} 
for a~given input project.

The motivation behind a~CD is simple.
If a~source file uses unusual include paths that need to be provided 
using the~\icode{-I} compiler command, it cannot be reliably compiled.
Similarly, if the~file contains macros and lacks definitions, its content 
can drastically change when the~definitions are present.
In the~latter case, definitions are provided to the~compiler 
with the~\icode{-D} command.
Such compiler commands, options, and flags are usually defined in~a build 
system.
At least, that is the~recommended practice for larger projects.
Having a~build system is similar to having a~CD.
It is clear which file is compiled with which options.

Clang expects a~CD in~the JSON format and looks for the~file specifically
named  \icode{compile\_commands.json} in~the current or parent 
directories.
The JSON file contains entries for source files.
Each entry contains a~directory, a~file name, and a~compilation command.
Multiple entries for a~single source file are also valid.
Such a~case can arise when performing repeated compilation.

As previously mentioned, having a~build system helps.
Build tools such as CMake and Ninja can be used to generate a~CD.
If the~project is not using any of~the~compatible build tools, 
the user can either make a~CD manually or use an external tool.
One such tool is Build EAR available at \url{https://github.com/rizsotto/Bear}.

Tools created using LibTooling do not always require compilation databases 
to run.
For simple projects, they can take the~\icode{-{}-} argument that separates 
the tool's arguments from the~project's compilation arguments.
One can interpret the~arguments following \icode{-{}-} as a~temporary
compilation database.

\section{Clang AST}\label{chap:ast}

The abstract syntax tree used in~the Clang front-end \citep{ast:online}
is different from the~typical AST. 
It saves and carries more data, namely context.  
For example, it contains additional information to map source 
code to nodes and capture semantics. 
This chapter describes the Clang node type hierarchy, the tree's 
representation in memory, and different ways of traversing an AST.
\subsection{Node types}

Clang AST's nodes belong to a~vast class hierarchy. 
This hierarchy contains classes that represent every supported 
source code construct.
Nodes are of~four different types: statements (\icode{Stmt}), 
declarations (\icode{Decl}), specific declaration context 
(\icode{DeclContext}), and types (\icode{Type}). 
However, in~the APIs mentioned above, the~nodes do not share
a common ancestor.

The children of~\icode{Type} represent all available types.
The goal is to give each type in~the source code a~canonical type,
i.e., a~type stripped of~any typedef names. 
Canonical types are used for type comparison, while non-canonical 
types give complete information during diagnostics. 
The \icode{Decl} hierarchy's goal is to have a~class for each 
type of~declaration or definition. 
These declarations vary, and the~children cover specific cases 
such as function, structure, and enum declarations. 
Some declarations, such as function and namespace declarations, 
capture additional data in~\icode{DeclContext}'s children. 
The final node type, \icode{Stmt}, represents a~single statement. 
It has subclasses for loops, control statements, compound statements, 
and more. 
Additionally, expressions (\icode{Expr}) also belong 
to the~\icode{Stmt} hierarchy.

Figure~\ref{dia:ast} shows a~part of~the~class hierarchy. 
The entire class diagram cannot be shown as there are over a~thousand 
different classes\footnote{The class hierarchy is shown in~Clang's
Doxygen documentation. An example of~the~Stmt hierarchy can be found
at \url{https://clang.llvm.org/doxygen/classclang_1_1Stmt.html}.}. 
The topmost node, the~root, of~a~concrete Clang AST is called the~translation
unit declaration (\icode{TranslationUnitDecl}). 
Edges between nodes are simplified, as each node stores 
a container of~its children.

\begin{figure}[ht]\centering
\begin{tikzpicture}
	\begin{class}[text width=2cm]{Stmt}{-5.5, 0}
	\end{class}

	\begin{class}[text width=2.5cm]{ValueStmt}{-5.5, -6}		
		\inherit{Stmt}
	\end{class}

	\begin{class}[text width=2cm]{Expr}{-5.5, -8}
		\inherit{ValueStmt}
	\end{class}

	\begin{class}[text width=1.75cm]{IfStmt}{-4.25, -2.75}
		\inherit{Stmt}
	\end{class}

	\begin{class}[text width=2cm]{Type}{-2, 0}
	\end{class}

	\begin{class}[text width=2.5cm]{ArrayType}{-3.5, -4.25}
		\inherit{Type}
	\end{class}

	\begin{class}[text width=3cm]{DeducedType}{-2, -6}
		\inherit{Type}
	\end{class}

	\begin{class}[text width=2.5cm]{AutoType}{-2, -8}
		\inherit{DeducedType}
	\end{class}

	\begin{class}[text width=2cm]{Decl}{1.5, 0}
	\end{class}

	\begin{class}[text width=2.5cm]{EmptyDecl}{-0.25, -2.75}
		\inherit{Decl}
	\end{class}

	\begin{class}[text width=2.5cm]{NamedDecl}{1.5, -6}
		\inherit{Decl}
	\end{class}

	\begin{class}[text width=2.5cm]{TypeDecl}{1.5, -8}
		\inherit{NamedDecl}
	\end{class}

	\begin{class}[text width=3cm]{DeclContext}{4.75, 0}
	\end{class}

	\begin{class}[text width=2.25cm]{BlockDecl}{3.25, -4.25}
		\inherit{DeclContext}
	\end{class}

	\begin{class}[text width=2.5cm]{TagDecl}{4.75, -6}
		\inherit{DeclContext}
	\end{class}
	
	\begin{class}[text width=2.5cm]{EnumDecl}{4.75, -8}
		\inherit{TagDecl}
	\end{class}
\end{tikzpicture}
\caption{An example of~the~Clang AST class hierarchy. 
The figure contains only a~handful of~classes and their children.
Note that the~top most classes do not share a~common ancestor.}
\label{dia:ast}
\end{figure}

Listing~\ref{lst:astdump} contains a~short program written in~C++.
The source code was provided to a~Clang tool clang-check, which
dumped the~abstract syntax subtree of~a~given function.
In this case, the~filter was set to the~\icode{main} function.
The AST dump visualizes the~subtree using ASCII characters
and node information.
Nodes entries start with their type names. 
Each node also carries its address, source location, and description.
Note that the~root of~the~subtree is of~type \icode{FunctionDecl}.
The usual root \icode{TranslationUnitDecl} is absent due to the~function
filter being applied.

\begin{figure}[ht]\centering
\begin{lstlisting}[language=bash, basicstyle=\small, numbers=none]
$ cat -n simple.cpp
     1  #include<iostream>
     2
     3  int main()
     4  {
     5          int x;
     6          std::cin >> x;
     7
     8          return (x / 42);
     9  } 
$ clang-check -ast-dump -ast-dump-filter=main simple.cpp --
Dumping main:
FunctionDecl '...' <./simple...> line:3:5 main 'int ()'
`-CompoundStmt 0x556041ab84a0 <line:4:1, line:9:1>
  |-DeclStmt 0x556041ab6900 <line:5:2, col:7>
  | `-VarDecl 0x556041ab6898 <col:2, col:6> col:6 used x 'int'
  |-CXXOperatorCallExpr '...' <line:6:2, col:14> 'std::bas...'
  | |-ImplicitCastExpr 0x556041ab83a0 <col:11> 'std::basic...'
  | | `-DeclRefExpr 0x556041ab8318 <col:11> 'std::basic...'
  | |-DeclRefExpr 0x556041ab6980 <col:2, col:7> 'std::istr...'
  | `-DeclRefExpr '...' <col:14> 'int' lvalue Var '...' 'x'
  `-ReturnStmt 0x556041ab8490 <line:8:2, col:16>
    `-ParenExpr 0x556041ab8470 <col:9, col:16> 'int'
      `-BinaryOperator '...' <col:10, col:14> 'int' '/'
        |-ImplicitCastExpr '...' <col:10> 'int' <LValueToRValue>
        | `-DeclRefExpr 0x556041ab83f8 <col:10> 'int...'
        `-IntegerLiteral 0x556041ab8418 <col:14> 'int' 42
\end{lstlisting}
\caption{Clang AST Dump. The example source code visible
in the figure has been filtered by function name and fed
to a Clang tool.}
\label{lst:astdump}
\end{figure}

\subsection{Representation}

The Clang AST attempts to represent the~source code as faithfully 
as possible. 
It can be said that Clang's AST is closer to C, C++, 
and Objective-C code and grammar than other ASTs. 
To achieve the~best accuracy in~reproducing a~source code file, 
it must save additional data besides the~AST. 
This supplementary data makes information that would be lost 
otherwise, such as compile-time constants, available 
in the~unreduced form. 

For each parsed source code file, an instance of~\icode{ASTContext} 
is used to represent the~AST. 
The \icode{ASTContext} allows the~programmer to use many valuable methods. 
Table~\ref{tab:astcontext} contains a part of \icode{ASTContext}'s Doxygen 
documentation. 
It mainly presents methods that were used in this project.

\begin{table}[b!]\centering
	\begin{tabular}{p{0.25\linewidth} p{0.37\linewidth} p{0.29\linewidth}}
		\toprule \mc{\textbf{Return}} & \mc{} & \mc{}\\
		\mc{\textbf{value}} & \pulrad{\textbf{Method name}} &
		\mc{\pulrad{\textbf{Description}}} \\
		\midrule
		\icode{DynTypedNodeList} & \icode{getParents(const NodeT \&Node)} & 
		Forwards to get node parents from the \icode{Parent\-Map\-Context}. \\
		\icode{SourceManager\&} & \icode{getSourceManager()} & --- \\
		\icode{const TargetInfo\&} & \icode{getTargetInfo() const} & --- \\
		\icode{const LangOptions\&} & \icode{getLangOpts() const} & --- \\
		\icode{TranslationUnit\-Decl*} & \icode{getTranslationUnitDecl()} & 
		--- \\
		\bottomrule
	\end{tabular}
\caption{Digest of \icode{ASTContext}'s documentation.
The documentation can be found at
\url{https://clang.llvm.org/doxygen/classclang_1_1ASTContext.html}.}
\label{tab:astcontext}
\end{table}

The ASTContext bundles Clang's AST for a~translation unit 
and allows its traversal from the~\icode{getTranslationUnitDecl}
point, which is the~file's highest node. 
Additionally, the~context has access to the~identifier table 
and the~source manager. 
The \icode{SourceManager} class offloads some of~the~data 
from AST's nodes. 
Nodes store their \icode{SourceLocation}. 
The location is not in~its complete form since it is required 
to be small in~size. 
Instead, the~node's full location is referenced 
in \icode{SourceManager}.

Extracting Clang AST comes at the~cost of~compiling the~program's
source code. 
Usually, this is done using an instance of~\icode{FrontEndAction}, 
which specifies what and how should be compiled. 
The front-end compilation is essential to note because it can affect 
LibTooling's performance on large projects. 
In comparison, clang-format does not execute any compilations. 
Therefore, clang-format runs efficiently on large projects 
and correctly on incomplete ones. 
The compilation action also implies that LibTooling tools often 
do not support incomplete source codes. 
The same can be said for programs that contain compile-time errors.

\begin{figure}[h]\centering
\begin{lstlisting}[language=C++]
/**
 * Creates a consumer, performs actions after 
 * the AST traversal.
 */
class CountAction final : public ASTFrontendAction
{
	int statementCount_;
	
public:

	// Perform the desired action after the traversal.
	void EndSourceFileAction() override
	{
		outs() << "Statement count: " 
			<< statementCount_ << "\n";
	}

	std::unique_ptr<ASTConsumer> CreateASTConsumer(
		CompilerInstance& ci, StringRef file) override
	{
		// Pass any data to the consumer.
		return std::unique_ptr<ASTConsumer>(
			std::make_unique<CountASTConsumer>(
				&ci, statementCount_));
	}
};
\end{lstlisting}
\caption{Custom ASTFrontendAction. An instance can be created before
parsing a source file. The example shows the ability to perform
a body of actions after the file is parsed.}
\label{lst:astfrontendaction}
\end{figure}

An additional characteristic of~Clang's AST is its immutability. 
The AST has strong invariants that might be broken upon changing 
its structure. 
Generally, changes to the~Clang AST are strongly discouraged, 
although some changes happen internally. 
Those changes include template instantiation.

\subsection{Traversal}

Traversing the~Clang AST is possible through two different APIs. 
First, it is possible to invoke an \icode{ASTFrontendAction} instance, 
which creates and manages an instance of \icode{ASTConsumer}. 
The latter then constructs the \icode{ASTRecursiveVisitor} object and 
calls the visitor's methods. 
The front-end action is invoked upon parsing a~source file. 
The action can be overridden to create a~consumer and pass any necessary 
data to it. 
For example, this data might include references to variables used for 
counting objects in~the AST or more complicated constructs. 

Listing~\ref{lst:astfrontendaction} showcases an example of such frontend 
action. 
The custom class contains a variable used for counting statements 
in the source code. 
The reference to that variable is passed further when creating a consumer. 
After the source code is parsed, the overridden \icode{EndSourceFileAction} 
method is launched. 
Inside the method's body, the data gathered during the traversal is 
displayed.

\begin{figure}[H]\centering
\begin{lstlisting}[language=C++]
/**
 * Dispatches the CountASTVisitor on the translation 
 * unit decl.
 */
class CountASTConsumer final : public ASTConsumer
{
	std::unique_ptr<CountASTVisitor> visitor_;

public:
	// Pass any desired data to the visitor.
	CountASTConsumer(CompilerInstance* ci, int& counter)
		: visitor_(std::make_unique<CountASTVisitor>(ci, counter)) { }

	void HandleTranslationUnit(ASTContext& context) override
	{
		// Use the ASTContext to reference 
		// the translation unit decl.
		visitor_->TraverseDecl(
			context.getTranslationUnitDecl());
	}
};
\end{lstlisting}
\caption{An example of a custom ASTConsumer implementation.
Showcased is the ability to transfer data to a visitor and
to dispatch the visitor.}
\label{lst:astconsumer}
\end{figure}

The \icode{ASTConsumer}'s job is to read the~Clang AST and handle actions
on the~tree's specific items. 
One such action is \icode{HandleTopLevelDecl()}, which, as the~name suggests,
handles the~highest priority declaration in~a file. 
These handle functions are overridable. 
The consumer also keeps track of~a~visitor implemented by inhering from 
the ASTRecursiveVisitor class. 
The consumer dispatches the~visitor from overridden handle methods. 
However, it is not always beneficial to override granular handle methods. 
Handling specific events in~the consumer might lead to an intriguing case 
in which a~part of~the~code is parsed while the~rest is not. 
This unwanted behavior can be avoided by overriding just 
the \icode{HandleTranslationUnit()} method. 
The translation unit is handled once the~entire source file is parsed. 
Dispatching the~visitor internally from a~consumer is the~preferred 
approach. 
Visit methods of~the~\icode{ASTRecursiveVisitor} should not be called 
directly. 
Details concerning the~visitor can be found in~the following section.

In the example shown in listing~\ref{lst:astconsumer}, the consumer passes 
variable references to the visitor. 
These references have previously been attained from the frontend action. 
A reference to the constructed visitor is stored inside the consumer. 
The visitor is then dispatched in the overridden 
\icode{HandleTranslationUnit} method. 
As was described earlier, \icode{ASTContext} helps to retrieve references 
to top-level nodes.

Second, one can use AST Matchers. 
Matchers, unlike the~visitor approach, do not require a~complicated setup. 
Instead, they provide a~query-like syntax for matching Clangs AST's nodes. 
Matchers will be talked about in~detail later.

\section{ASTVisitor}

LibTooling offers a~built-in curiously recurring template pattern 
(CRTP) visitor. 
The class \icode{RecursiveASTVisitor} \citep{visitor:online} 
offers \icode{Visit} methods that 
can be overridden to the~programmer's liking. 
Each override specifies the~type of~node on which the~method 
triggers and the~actions that should be performed.
A portion of these methods is presented in table~\ref{tab:astvisitor}. 
The table's contents are based on the Doxygen documentation.

\begin{table}[b!]\centering
	\begin{tabular}{p{0.39\linewidth} p{0.52\linewidth}}
		\toprule \\
		\pulrad{\textbf{Method}$^a$} & \mc{\pulrad{\textbf{Description}}} \\
		\midrule
		\icode{shouldVisitImplicitCode()} & Return whether this 
		visitor should recurse into implicit code, e.g., implicit constructors 
		and destructors. \\
		\icode{shouldTraversePostOrder()} & Return whether this 
		visitor should traverse post-order. \\
		\icode{TraverseAST(ASTContext \&AST)} & Recursively 
		visits an entire AST, starting from the top-level Decls in the AST 
		traversal scope (by default, the \icode{TranslationUnitDecl}). \\
		\icode{TraverseStmt(Stmt *S, DataRecursionQueue 
		*Queue=nullptr)} & Recursively visit a statement or expression, by 
		dispatching to \icode{Traverse*()} based on the argument's dynamic 
		type. \\
		\icode{TraverseType(QualType T)} & Recursively visit a 
		type, by dispatching to \icode{Traverse*Type()} based on the 
		argument's \icode{getTypeClass()} property. \\
		\icode{TraverseDecl(Decl *D)} & Recursively visit a 
		declaration, by dispatching to \icode{Traverse*Decl()} based on the 
		argument's dynamic type. \\
		\icode{WalkUpFromStmt(Stmt *S)} & --- \\
		\icode{VisitStmt(Stmt *S)} & --- \\
		\icode{WalkUpFromType(Type *T)} & --- \\
		\icode{VisitType(Type *T)} & --- \\
		\icode{WalkUpFromDecl(Decl *D)} & --- \\
		\icode{VisitDecl(Decl *D)} & --- \\
		\bottomrule
		\multicolumn{2}{l}{\footnotesize \textit{Note:}
		$^a$ All presented methods return \icode{bool}.}
	\end{tabular}
\caption{Digest of \icode{RecursiveASTVisitor}'s documentation.
The documentation can be found at 
\url{https://clang.llvm.org/doxygen/classclang_1_1RecursiveASTVisitor.html}.}
\label{tab:astvisitor}
\end{table}

The implementation seen on listing~\ref{lst:countvisitor} illustrates
the idea. a~custom class with a~strict dedication, i.e., counting
program's statements, has two visit functions.
Firstly, a~\icode{VisitStmt} method, which is triggered upon
encountering a~node of~type \icode{Stmt}, as seen in~its
parameters. 
Furthermore, since no additional visit functions for children 
of \icode{Stmt} have been overridden, \icode{VisitStmt}
will trigger on every node type inheriting from \icode{Stmt} as well.
Secondly, the~method \icode{VisitVarDecl} only accepts \icode{VarDecl}
and its inheriting types.
Because \icode{VarDecl} is a~child of~\icode{Decl}, not the~other way
around, \icode{Decl} will not trigger this visit function.
Typically, when using less specific visit methods, a~good 
way of~differentiating node types is casting them dynamically.

\begin{figure}[ht]\centering
\begin{lstlisting}[language=C++]
/**
 * Counts the number of statements.
 */
class CountASTVisitor : public clang::RecursiveASTVisitor<CountASTVisitor>
{
        clang::ASTContext& astContext_;
        int& statementCount_;

public:
        CountASTVisitor(clang::CompilerInstance* ci, int& counter)
                : astContext_(&ci->getASTContext()), 
					statementCount_(counter) { }

		// Perform a body of actions upon 
		// encountering a statement.
        virtual bool VisitStmt(clang::Stmt* st)
        {
                outs() << "Found a statement.\n";
				statementCount_++;
				
                return true;
        }
		
		// Perform a body of actions upon encountering 
		// a variable declaration.
		virtual bool VisitVarDecl(clang::VarDecl* decl)
        {
                outs() << "Found a variable declaration.\n";
				
                return true;
        }
};
\end{lstlisting}
\caption{CountASTVisitor. A custom implementation of the ASTRecursiveVisitor
which tracks the number of encountered statements.}
\label{lst:countvisitor}
\end{figure}

Visiting statements, expressions, declarations, 
and types is straightforward. 
The same applies to children of~these classes. 
However, it is challenging to visit more complicated entities 
such as nested types, e.g., \icode{int* const* x}. 
Such cases require navigation through source locations in order to reach 
a particular built-in type.
In an example from the LLVM Euro Conference 2013\footnote{The particular 
speech in which the example is mentioned can be found 
at \url{https://youtu.be/VqCkCDFLSsc?t=916}. The recording starts at
the relevant slide.}, 
one can reach the built-in type of \icode{int * p;} in two ways. 
The declaration is for a pointer type, which has a \icode{PointerTypeLoc}. 
On the one hand, it is possible to reach the \icode{BuiltinType} node by 
calling the \icode{getPointeeLoc()} method. 
The result is a \icode{BuiltinTypeLoc} instance, through which 
a \icode{QualType} object can be extracted. 
The qualifier leads to the desired \icode{BuiltinType} instance. 
On the other hand, one can extract a \icode{QualType} object from 
the starting \icode{PointerTypeLoc} node and use it to get 
a \icode{PointerType} instance. 
By calling the \icode{getPointeeType()} method, it is possible to get to 
the \icode{QualType} node that leads to the desired built-in type. 

Both of these approaches start at the same source location and end 
with the same built-in type object. 
The steps necessary to traverse this simple pointer type, however, 
were not trivial.

The \icode{RecursiveASTVisitor} is launched by visiting the~root node using 
a \icode{TraverseDecl} method. 
It then dispatches to other nodes and their children. 
For each node, the~visitor searches the~class hierarchy from 
the node's dynamic type up. 
Once the~type is determined, the~visitor calls the~appropriate 
overridden \icode{Visit} method. 
Traversing the class hierarchy this way translates to calling the methods 
for abstract types first, followed by more specific visit functions.

The tree traversal can be done in~a preorder or postorder fashion. 
Preorder traversal is the~default. the~developer can also stop
the traversal at any point by returning \icode{false} from
the visit function as opposed to \icode{true}.

\section{Matchers}

Clang's ASTMatchers \citep{matchers:online} 
is a~domain-specific language (DSL) used for querying 
specified AST nodes. 
Each matcher represents a~predicate on nodes. 
Together, they form a~query-like expression that matches particular nodes. 
Like the~rest of~LibTooling, the~DSL is written in~C++ and is used from 
C++ as well.
Matchers are useful for query tools and code transformations. 
In a~query tool, one might want to extract a~niche subset of~Clang's AST, 
inspect it, and perhaps perform some action on it. 
Similarly, refactoring tools can use matchers to navigate and extract 
similar nodes, rewrite their source code, or add descriptive comments.
A matcher will match on some adequate node. 
It might match multiple times if the~AST has enough of~these nodes. 
When combined, multiple matchers form a~matcher expression. 
Such expression can be seen as a~query for the~Clang AST. 
The expression reads like an English sentence, from left to right, 
alternating several type-specifying and node-narrowing matchers.

All available matchers fall into three basic categories. 
The first one being node matchers. 
Node matcher's job is to match a~specific type of~AST node. 
An example of~such a~matcher could be the~\icode{binaryOperator(...)} 
matcher, whose purpose is to look for nodes of~that exact 
type: \icode{BinaryOperator}. 
Node matchers are the~core of~matcher expressions. 
Expressions start with them, and they specify which node type is expected. 
Node matchers also serve as arguments for other matcher types. 
Furthermore, they allow binding nodes. 
Binding nodes allows the~programmer to retrieve matched nodes later and 
use them for code transformation tasks. 

The second category, called narrowing matchers, serves a~different purpose. 
By matching specific attributes on the~current AST node, they narrow down 
the search range. 
Narrowing matchers allow specifying more granular demands for the~searched 
node. 
A concrete example would be the~\icode{hasOperatorName("+")} matcher. 
As one might guess, this matcher narrows down the~search to those nodes 
whose binary operator is the~plus sign. 
Narrowing matchers also provide more general logical matchers. 
These include \icode{allOf}, \icode{anyOf}, \icode{anything}, 
and \icode{unless}.

The last category specifies the~relationship between nodes. 
Traversal matchers are used for filtering reachable nodes based on 
the AST's structure. 
Most notably, they include matchers for specifying node's children, 
such as \icode{has}, \icode{hasDescendant}, and \icode{forEachDescendant}. 
Traversal matchers take node matchers, the~first category, as arguments. 
For example, the~\icode{hasLHS(integerLiteral(equals(0)))} matcher specifies
the requirement for the~current node to have the~given child. 
In this case, it is an integer with the~value 0 on the~left hand side.

Together, these three examples form a~matcher expression found in
the AST Matcher tutorial\footnote{The AST Matcher tutorial contains 
valuable practical information as well as a well-written introduction
to matchers. It can be found at 
\url{https://clang.llvm.org/docs/LibASTMatchersTutorial.html}.}. 
Going by the~mentioned rules of~building an expression, it would have 
the following form: 

\begin{figure}[H]\centering
\begin{lstlisting}[language=C++, numbers=none]
binaryOperator(hasOperatorName("+"), hasLHS(integerLiteral(equals(0)))).
\end{lstlisting}
\caption{Matcher expression.}
\label{lst:matcherexpr}
\end{figure}

The expression in listing~\ref{lst:matcherexpr} searches for a~binary 
operator. 
The search is further narrowed to a~plus sign with a~zero left-hand 
side of~the~operation.

In the~tool, expressions are build by calling a~creator function. 
The expression is then represented as a~tree of~matchers. 
While the~developer has access to a~plethora of~predefined matchers, 
as seen in~the Matchers Reference \citep{matchersreference:online}, 
they can define custom ones as well. 
Creating a~custom matcher can be done in~two ways. 
First, a~matcher can be created by inheriting an existing Matcher class 
and overriding it to one's liking. 
Second, one can use a~matcher creation macro. 
These macros specify the~type, the~name, and the~parameters of~the~matcher.

The default behavior, defined by the~\icode{AsIs} mode, is to traverse 
the entire AST and visit all nodes, including implicit ones. 
Implicit nodes might include constructs omitted in~the source code, 
such as parentheses. 
Working with these nodes increases the~difficulty of~writing matcher 
expressions severely since it requires a~deep knowledge of~the~AST's 
hierarchy and its corner-cases. 
The traversal mode can, however, be changed to ignore implicit nodes. 
One such traversal mode is \icode{IgnoreUnlessSpelledInSource}, 
which conveniently only looks at nodes represented by the~source code. 

\section{Source-to-source transformation}\label{chap:sts}

To transform source code based on its AST, the~programmer must extract 
the AST from the~code, alter the~AST, and then translate it back to valid 
source code. 
LibTooling allows the~programmer to extract the~AST and examine it. 
Additional functionality also allows modifying the~AST both directly 
and indirectly \citep{sourcetosource:online}. 
However, there are obstacles and limitations to both approaches. 

Let us examine the~pitfalls of~direct AST transformation first. 
Before explaining the~possibilities of~direct modifications, it 
should be noted that these transformations are not recommended. 
Clang has powerful invariants about its AST, and changes might 
break them. 
Although it is not encouraged, the~methods to change the~AST 
are available.

Given an \icode{ASTContext}, it is possible to create specific nodes
using their \icode{Create} method. 
Likewise, nodes with public constructors and destructors can combine 
keywords \icode{placement new}, \icode{delete} and the~ASTContext 
to add or remove nodes. 
The job of~\icode{ASTContext} is then to manage the~memory internally.

A more sophisticated approach is the~one offered 
by the~\icode{TreeTransform} class. 
Although it is rarely used and no real examples can be found, 
the premise is simple. 
The \icode{TreeTransform} class needs to be inherited from, 
and its \icode{Rebuild} methods need to be overridden. 
The overrides then transform specified nodes of~an input AST 
into a~modified AST.

One additional dirty way of~replacing nodes is by utilizing 
\icode{std::replace}. 
The child container of~the~replaced node's immediate parent must be 
specified in~parameters of~\icode{std::replace}, together with 
the node itself and the~new node.

When attempting to modify the~AST indirectly, which is how LibTooling 
intends it to, the~developer can run into a~couple of~issues. 
First of~all, the~AST does not reference the~source code entirely. 
The programmer has access to \icode{SourceManager}, \icode{Lexer},
\icode{Rewriter}, and \icode{Replacement} classes. 
When used individually or in~combinations, they can map to and alter 
a given node's source code.
It is then possible to add, remove, or replace the~AST's underlying 
code with node-level precision.

Accessing this information through these classes can result in~
node-to-code mapping issues. 
Compound statements might mismatch parentheses and curly brackets. 
Similarly, declarations and statements might miss a~reference to 
a semicolon. 
These and more obstacles could surface anytime a~programmer attempts 
to debug their source-to-source transformation tool. 

The programmer must be careful in~managing object instances when 
transforming multiple files. 
Each source file creates a~new FrontendAction, and with it, 
the developer needs a~new instance of~Rewriter.

Discovering these obstacles is not as straightforward and intuitive as 
the rest of the LibTooling framework.
Templates, the~language feature of~C++, further complicate the~matter. 
In Clang AST, multiple types derived from a~template might share some nodes. 
Having multiple parent nodes is also not uncommon for template types. 
Thankfully, templates are rarely used. 
A more common threat, macros, has a~similar effect. 
Modifying a~source code containing macros and comments results in~
losing both.

Doing source-to-source transformation is often accompanied by 
inserting instrumentation code. 
By performing so-called cross-checking, one can make sure that 
the transformation behaves as intended. 
Cross-checking works by inserting code with the~same behavior 
into the~original and the~transformed source code.  
This insertion can be done in~a sophisticated manner using the~AST. 
If, for example, the~transformation alters calls to functions 
in the~code, the~instrumentation code should be inserted inside the~
function's body—that way, the~developer can check whether 
the transformation had its intended result.
Cross-checking is a~safe way of~ensuring source-to-source 
transformations work as intended. 
While they might be excessive for small refactorings, 
they are beneficial when debugging source-to-source 
transformations of~larger scales, such as translating 
one language's source code to another's.

We thought about using instrumentation as a validation technique for our 
implementation. 
However, implementing this approach is not a simple task. 
It is still essential that the reader knows the possibilities of 
source-to-source transformation, including cross-checking.