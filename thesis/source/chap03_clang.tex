\chapter{Clang LibTooling}

\change[inline]{TODO: Convert links into references (
\url{https://llvm.org/} 
and \url{https://clang.llvm.org/} 
and \url{https://clang.llvm.org/docs/LibTooling.html}
and \url{https://clang.llvm.org/docs/IntroductionToTheClangAST.html}
and \url{https://eli.thegreenplace.net/2014/05/01/modern-source-to-source-transformation-with-clang-and-libtooling}
and \url{https://clang.llvm.org/doxygen/classclang_1_1RecursiveASTVisitor.html}
and \url{https://eli.thegreenplace.net/2014/05/01/modern-source-to-source-transformation-with-clang-and-libtooling}
and \url{https://eli.thegreenplace.net/2014/05/21/compilation-databases-for-clang-based-tools}
and \url{https://kevinaboos.wordpress.com/2013/07/23/clang-tutorial-part-ii-libtooling-example/}
and \url{https://llvm.org/devmtg/2017-06/2-Hal-Finkel-LLVM-2017.pdf}
and \url{https://clang.llvm.org/docs/LibASTMatchersReference.html}
and \url{https://clang.llvm.org/docs/LibASTMatchers.html}
)}

\change[inline]{TODO: Add a paragraph (or a subsection) about compilation databases.}

The previous chapter described tools and environments that were taken
into consideration for this project. 
The utmost importance was given to the ease of use, availability, and 
active community. 
As the reader might have guessed from the summary, the LLVM/Clang 
suite stood out as the best candidate.

Clang is a language front-end. With high compilation performance, 
low memory footprint, and modifiable code base, it quickly and flexibly 
converts source code to LLVM intermediate code representation. 
The front-end supports languages and frameworks such as C/C++, 
Objective C/C++, CUDA, OpenCL, OpenMP, RenderScript, and HIP. 
This support is crucial for this thesis since the project 
aims to support both C and C++. 
The LLVM Core then handles the optimization and IR synthesis, 
supporting a plethora of popular CPUs.

Clang is widely used for its warnings and error checks, both very 
helpful and outstanding compared to competing compilers. 
Furthermore, Clang offers an extensive tooling infrastructure 
through which tools such as clang-tidy were developed. 
A relatively well-documented tooling API written in C++ helps 
programmers create their tools easily. 
However, not all developers share the same skill floor and skill ceiling. 
Some programmers require complicated additional features, while others 
prefer an easy-to-use interface. 
The tooling API has been split into multiple libraries and frameworks. 

For plugin development, a library intuitively called Plugins is used.
The library is linked dynamically, resulting in relatively small tools.
Plugins are launched at compilation and offer compilation control as well 
as access to the AST.

More specifically, Plugins allow performing an extra custom front-end action 
during compilation.
The functionality is generally similar to that of LibTooling, which will be 
talked about later.
However, unlike a standalone tool, Plugins cannot do any tasks before and after 
the analysis (and compilation).
When creating a plugin, one can choose from a selection of 
\icode{FrontendAction} classes to inherit.
If, for example, the plugin should work with the AST, 
the \icode{ASTFrontendAction} can be inherited.
Doing so also allows overriding the \icode{ParseArgs} method, in which 
the plugin's command line handling is specified.

Due to dynamic loading, the wanted plugin must be added to a plugin registry 
inside the code.
The plugin is then loaded from the registry by specifying the \icode{-load} 
command or \icode{-fplugin} on the command line when running clang.
The plugin takes those arguments from the command line that are prefixed 
by \icode{-Xclang}.

Another framework, LibClang, offers a simple C and Python API for quick 
tool writing. 
Unlike Plugins and LibTooling, which will be mentioned later, the code 
base of LibClang is stable. 
This stability implies that tools written using LibClang do not require
upkeep with every new LLVM/Clang release. 
Overall, the framework and tools written using it are high-level and 
are easily readable.

The most feature woven set of libraries is LibTooling. 
Unlike Plugins, LibTooling allows the developer to build standalone 
Clang tools. 
This robust framework is written in C++ and has an active 
community of contributors. 
One can find many manuals and tutorials online. 
However, with each contribution to LibTooling and each release of Clang, 
there is a chance that older tools will not support the newer LibTooling 
API. 
That is the reason why countless tools written using this framework do not
run in modern environments. 
Programmers who use LibTooling cannot expect compatibility in upcoming 
releases. 
On the bright side, the libraries of LibTooling allow a plethora of source
code modifications, AST traversals, and access to the compiler's internals.

\section{Compilation databases}

To accurately and faithfully recreate a compilation, tools created using 
LibTooling require a compilation database (CD) for a given input project.

The motivation behind a CD is simple.
If a source file uses unusual include paths that need to be provided 
using the \icode{-I} compiler command, it cannot be reliably compiled.
Similarly, if the file contains macros and lacks definitions, its content 
can drastically change when the definitions are present.
In the latter case, definitions are provided to the compiler 
with the \icode{-D} command.
Such compiler commands, options, and flags are usually defined in a build 
system.
At least, that is the recommended practice for larger projects.
Having a build system is similar to having a CD.
It is clear which file is compiled with which options.

Clang expects a CD in the JSON format and looks for the file specifically
named  \icode{compile\_commands.json} in the current or parent 
directories.
The JSON file contains entries for source files.
Each entry contains a directory, a file name, and a compilation command.
Multiple entries for a single source file are also valid.
Such a case can arise when performing repeated compilation.

As previously mentioned, having a build system helps.
Build tools such as CMake and Ninja can be used to generate a CD.
If the project is not using any of the compatible build tools, 
the user can either make a CD manually or use an external tool.
One such tool is Build EAR available at \url{https://github.com/rizsotto/Bear}.

Tools created using LibTooling do not always require compilation databases 
to run.
For simple projects, they can take the \icode{-{}-} argument that separates 
the tool's arguments from the project's compilation arguments.
One can interpret the arguments following \icode{-{}-} as a temporary
compilation database.

\section{Clang AST}

The abstract syntax tree used in the Clang front-end is different 
from the typical AST. 
It saves and carries more data, namely context.  
For example, it contains additional information to map source 
code to nodes and capture semantics. 

Its nodes belong to a vast class hierarchy. 
This hierarchy contains classes that represent every supported 
source code construct.
Nodes are of four different types: statements (\icode{Stmt}), 
declarations (\icode{Decl}), declaration context (\icode{DeclContext}),
and types (\icode{Type}). 
However, in the APIs mentioned above, the nodes do not share
a common ancestor. 
The topmost node, the root, of Clang AST is called the translation
unit declaration (\icode{TranslationUnitDecl}). 
Edges between nodes are simplified, as each node stores 
a container of its children.

\begin{lstlisting}[caption=Clang AST Dump., language=bash, 
label={lst:astdump}, basicstyle=\tiny, numbers=none]
$ cat -n simple.cpp
     1  #include<iostream>
     2
     3  int main()
     4  {
     5          int x;
     6          std::cin >> x;
     7
     8          return (x / 42);
     9  } 
$ clang-check -ast-dump -ast-dump-filter=main simple.cpp --
Dumping main:
FunctionDecl 0x556041ab67e0 <./simple.cpp:3:1, line:9:1> line:3:5 main 'int ()'
`-CompoundStmt 0x556041ab84a0 <line:4:1, line:9:1>
  |-DeclStmt 0x556041ab6900 <line:5:2, col:7>
  | `-VarDecl 0x556041ab6898 <col:2, col:6> col:6 used x 'int'
  |-CXXOperatorCallExpr 0x556041ab83b8 <line:6:2, col:14> 'std::basic...'
  | |-ImplicitCastExpr 0x556041ab83a0 <col:11> 'std::basic...'
  | | `-DeclRefExpr 0x556041ab8318 <col:11> 'std::basic...'
  | |-DeclRefExpr 0x556041ab6980 <col:2, col:7> 'std::istream...'
  | `-DeclRefExpr 0x556041ab69b0 <col:14> 'int' lvalue Var 0x556041ab6898 'x' 'int'
  `-ReturnStmt 0x556041ab8490 <line:8:2, col:16>
    `-ParenExpr 0x556041ab8470 <col:9, col:16> 'int'
      `-BinaryOperator 0x556041ab8450 <col:10, col:14> 'int' '/'
        |-ImplicitCastExpr 0x556041ab8438 <col:10> 'int' <LValueToRValue>
        | `-DeclRefExpr 0x556041ab83f8 <col:10> 'int' lvalue Var 0x556041ab6898 'x' 'int'
        `-IntegerLiteral 0x556041ab8418 <col:14> 'int' 42
\end{lstlisting}

Listing~\ref{lst:astdump} contains a short program written in C++.
The source code was provided to a Clang tool clang-check, which
dumped the abstract syntax subtree of a given function.
In this case, the filter was set to the \icode{main} function.
The AST dump visualizes the subtree using ASCII characters
and node information.
Nodes entries start with their type names. 
Each node also carries its address, source location, and description.
Note that the root of the subtree is of type \icode{FunctionDecl}.
The usual root \icode{TranslationUnitDecl} is absent due to the function
filter being applied.

The Clang AST attempts to represent the source code as faithfully 
as possible. 
It can be said that Clang's AST is closer to C, C++, 
and Objective-C code and grammar than other ASTs. 
To achieve the best accuracy in reproducing a source code file, 
it must save additional data besides the AST. 
This supplementary data makes information that would be lost 
otherwise, such as compile-time constants, available 
in the unreduced form. 

For each parsed source code file, an instance of ASTContext 
is used to represent the AST. 
The ASTContext allows the programmer to use many valuable methods. 

\change[inline]{TODO: Show some of those functions from the documentation.}

The ASTContext bundles Clang's AST for a translation unit 
and allows its traversal from the \icode{getTranslationUnitDecl}
point, which is the file's highest node. 
Additionally, the context has access to the identifier table 
and the source manager. 
The \icode{SourceManager} class offloads some of the data 
from AST's nodes. 
Nodes store their \icode{SourceLocation}. 
The location is not in its complete form since it is required 
to be small in size. 
Instead, the node's full location is referenced 
in \icode{SourceManager}.

Extracting Clang AST comes at the cost of compiling the program's
source code. 
Usually, this is done using an instance of \icode{FrontEndAction}, 
which specifies what and how should be compiled. 
The front-end compilation is essential to note because it can affect 
LibTooling's performance on large projects. 
In comparison, clang-format does not execute any compilations. 
Therefore, clang-format runs efficiently on large projects 
and correctly on incomplete ones. 
The compilation action also implies that LibTooling tools often 
do not support incomplete source codes. 
The same can be said for programs that contain compile-time errors.

An additional characteristic of Clang's AST is its immutability. 
The AST has strong invariants that might be broken upon changing 
its structure. 
Generally, changes to the Clang AST are strongly discouraged, 
although some changes happen internally. 
Those changes include template instantiation.

Traversing the Clang AST is possible through two different APIs. 
First, it is possible to invoke an \icode{ASTFrontendAction}, which 
creates an \icode{ASTConsumer}, who then calls 
the \icode{ASTRecursiveVisitor}. 
The front-end action is invoked upon parsing a source file. 
The action can be overridden to create a consumer and pass any necessary 
data to it. 
For example, this data might include references to variables used for 
counting objects in the AST or more complicated constructs. 

The \icode{ASTConsumer}'s job is to read the Clang AST and handle actions
on the tree's specific items. 
One such action is \icode{HandleTopLevelDecl()}, which, as the name suggests,
handles the highest priority declaration in a file. 
These handle functions are overridable. 
The consumer also keeps track of a visitor implemented by inhering from 
the ASTRecursiveVisitor class. 
The consumer dispatches the visitor from overridden handle methods. 
However, it is not always beneficial to override granular handle methods. 
Handling specific events in the consumer might lead to an intriguing case 
in which a part of the code is parsed while the rest is not. 
This unwanted behavior can be avoided by overriding just 
the \icode{HandleTranslationUnit()} method. 
The translation unit is handled once the entire source file is parsed. 
Dispatching the visitor internally from a consumer is the preferred 
approach. 
Visit methods of the \icode{ASTRecursiveVisitor} should not be called 
directly. 
Details concerning the visitor can be found in the following section.

Second, one can use AST Matchers. 
Matchers, unlike the visitor approach, do not require a complicated setup. 
Instead, they provide a query-like syntax for matching Clangs AST's nodes. 
Matchers will be talked about in detail later.

\section{ASTVisitor}

LibTooling offers a built-in curiously recurring template pattern 
(CRTP) visitor. 
The class \icode{RecursiveASTVisitor} offers \icode{Visit} methods that 
can be overridden to the programmer's liking. 
Each override specifies the type of node on which the method 
triggers and the actions that should be performed.

The implementation seen on listing~\ref{lst:countvisitor} illustrates
the idea. A custom class with a strict dedication, i.e., counting
program's statements, has two visit functions.
Firstly, a \icode{VisitStmt} method, which is triggered upon
encountering a node of type \icode{Stmt}, as seen in its
parameters. 
Furthermore, since no additional visit functions for children 
of \icode{Stmt} have been overridden, \icode{VisitStmt}
will trigger on every node type inheriting from \icode{Stmt} as well.
Secondly, the method \icode{VisitVarDecl} only accepts \icode{VarDecl}
and its inheriting types.
Because \icode{VarDecl} is a child of \icode{Decl}, not the other way
around, \icode{Decl} will not trigger this visit function.
Typically, when using less specific visit methods, a good 
way of differentiating node types is casting them dynamically.

\begin{lstlisting}[caption=CountASTVisitor., language=C++, 
label={lst:countvisitor}]
/**
 * Counts the number of statements.
 */
class CountASTVisitor : public clang::RecursiveASTVisitor<CountASTVisitor>
{
        clang::ASTContext* astContext;
        int statementCount;

public:
        explicit CountASTVisitor(clang::CompilerInstance* ci)
                : astContext(&ci->getASTContext()), statementCount(0) { }

        virtual bool VisitStmt(clang::Stmt* st)
        {
                outs() << "Found a statement.\n";
				statementCount++;
				
                return true;
        }
		
		virtual bool VisitVarDecl(clang::VarDecl* decl)
        {
                outs() << "Found a variable declaration.\n";
				
                return true;
        }
};
\end{lstlisting}

Visiting statements, expressions, declarations, 
and types is straightforward. 
The same applies to children of these classes. 
However, it is challenging to visit more complicated entities 
such as nested types, e.g., \icode{int* const* x}. 
Such cases require fetching additional semantical context, 
utilizing \icode{ASTMatchers} and nodes of type declaration context.

\change[inline]{TODO: Show how complicated cases are handled.}

The \icode{RecursiveASTVisitor} is launched by visiting the root node using 
a \icode{TraverseDecl} method. 
It then dispatches to other nodes and their children. 
For each node, the visitor searches the class hierarchy from 
the node's dynamic type up. 
Once the type is determined, the visitor calls the appropriate 
overridden \icode{Visit} method. 
Traversing the class hierarchy from the bottom up 
translates to calling specific visit functions for specific types 
rather than visit functions of their abstract types.

The tree traversal can be done in a preorder or postorder fashion. 
Preorder traversal is the default. The developer can also stop
the traversal at any point by returning \icode{false} from
the visit function as opposed to \icode{true}.

\section{Matchers}

Clang's ASTMatchers is a domain-specific language (DSL) used for querying 
specified AST nodes. 
Each matcher represents a predicate on nodes. 
Together, they form a query-like expression that matches particular nodes. 
Like the rest of LibTooling, the DSL is written in C++ and is used from 
C++ as well.
Matchers are useful for query tools and code transformations. 
In a query tool, one might want to extract a niche subset of Clang's AST, 
inspect it, and perhaps perform some action on it. 
Similarly, refactoring tools can use matchers to navigate and extract 
similar nodes, rewrite their source code, or add descriptive comments.
A matcher will match on some adequate node. 
It might match multiple times if the AST has enough of these nodes. 
When combined, multiple matchers form a matcher expression. 
Such expression can be seen as a query for the Clang AST. 
The expression reads like an English sentence, from left to right, 
alternating several type-specifying and node-narrowing matchers.

All available matchers fall into three basic categories. 
The first one being node matchers. 
Node matcher's job is to match a specific type of AST node. 
An example of such a matcher could be the \icode{binaryOperator(...)} 
matcher, whose purpose is to look for nodes of that exact 
type: \icode{BinaryOperator}. 
Node matchers are the core of matcher expressions. 
Expressions start with them, and they specify which node type is expected. 
Node matchers also serve as arguments for other matcher types. 
Furthermore, they allow binding nodes. 
Binding nodes allows the programmer to retrieve matched nodes later and 
use them for code transformation tasks. 

The second category, called narrowing matchers, serves a different purpose. 
By matching specific attributes on the current AST node, they narrow down 
the search range. 
Narrowing matchers allow specifying more granular demands for the searched 
node. 
A concrete example would be the \icode{hasOperatorName("+")} matcher. 
As one might guess, this matcher narrows down the search to those nodes 
whose binary operator is the plus sign. 
Narrowing matchers also provide more general logical matchers. 
These include \icode{allOf}, \icode{anyOf}, \icode{anything}, 
and \icode{unless}.

The last category specifies the relationship between nodes. 
Traversal matchers are used for filtering reachable nodes based on 
the AST's structure. 
Most notably, they include matchers for specifying node's children, 
such as \icode{has}, \icode{hasDescendant}, and \icode{forEachDescendant}. 
Traversal matchers take node matchers, the first category, as arguments. 
For example, the \icode{hasLHS(integerLiteral(equals(0)))} matcher specifies
the requirement for the current node to have the given child. 
In this case, it is an integer with the value 0 on the left hand side.

Together, these three examples form a matcher expression found on 
\url{https://clang.llvm.org/docs/LibASTMatchersTutorial.html}. 
Going by the mentioned rules of building an expression, it would have 
the following form: 

\begin{lstlisting}[caption=Matcher expression., language=C++, 
label={lst:matcherexpr}, numbers=none]
binaryOperator(hasOperatorName("+"), hasLHS(integerLiteral(equals(0)))).
\end{lstlisting}

The expression in~\ref{lst:matcherexpr} searches for a binary operator. 
The search is further narrowed to a plus sign with a zero left-hand 
side of the operation.

In the tool, expressions are build by calling a creator function. 
The expression is then represented as a tree of matchers. 
While the developer has access to a plethora of predefined matchers, 
as seen here \url{https://clang.llvm.org/docs/LibASTMatchersReference.html}, 
they can define custom ones as well. 
Creating a custom matcher can be done in two ways. 
First, a matcher can be created by inheriting an existing Matcher class 
and overriding it to one's liking. 
Second, one can use a matcher creation macro. 
These macros specify the type, the name, and the parameters of the matcher.

The default behavior, defined by the \icode{AsIs} mode, is to traverse 
the entire AST and visit all nodes, including implicit ones. 
Implicit nodes might include constructs omitted in the source code, 
such as parentheses. 
Working with these nodes increases the difficulty of writing matcher 
expressions severely since it requires a deep knowledge of the AST's 
hierarchy and its corner-cases. 
The traversal mode can, however, be changed to ignore implicit nodes. 
One such traversal mode is \icode{IgnoreUnlessSpelledInSource}, 
which conveniently only looks at nodes represented by the source code. 

\section{Source-to-source transformation}

To transform source code based on its AST, it must extract the AST 
from the code, alter the AST, and then translate it back to valid 
source code. 
LibTooling allows the programmer to extract the AST and examine it. 
Additional functionality also allows modifying the AST both directly 
and indirectly. 
However, there are obstacles and limitations to both approaches. 

Let us examine the pitfalls of direct AST transformation first. 
Before explaining the possibilities of direct modifications, it 
should be noted that these transformations are not recommended. 
Clang has powerful invariants about its AST, and changes might 
break them. 
Although it is not encouraged, the methods to change the AST 
are available.

Given an \icode{ASTContext}, it is possible to create specific nodes
using their \icode{Create} method. 
Likewise, nodes with public constructors and destructors can combine 
keywords \icode{placement new}, \icode{delete} and the ASTContext 
to add or remove nodes. 
The job of \icode{ASTContext} is then to manage the memory internally.

A more sophisticated approach is the one offered 
by the \icode{TreeTransform} class. 
Although it is rarely used and no real examples can be found, 
the premise is simple. 
The \icode{TreeTransform} class needs to be inherited from, 
and its \icode{Rebuild} methods need to be overridden. 
The overrides then transform specified nodes of an input AST 
into a modified AST.

One additional dirty way of replacing nodes is by utilizing 
\icode{std::replace}. 
The child container of the replaced node's immediate parent must be 
specified in parameters of \icode{std::replace}, together with 
the node itself and the new node.

When attempting to modify the AST indirectly, which is how LibTooling 
intends it to, the developer can run into a couple of issues. 
First of all, the AST does not reference the source code entirely. 
The programmer has access to \icode{SourceManager}, \icode{Lexer},
\icode{Rewriter}, and \icode{Replacement} classes. 
When used individually or in combinations, they can map to and alter 
a given node's source code.
It is then possible to add, remove, or replace the AST's underlying 
code with node-level precision.

Accessing this information through these classes can result in 
node-to-code mapping issues. 
Compound statements might mismatch parentheses and curly brackets. 
Similarly, declarations and statements might miss a reference to 
a semicolon. 
These and more obstacles could surface anytime a programmer attempts 
to debug their source-to-source transformation tool. 

The programmer must be careful in managing object instances when 
transforming multiple files. 
Each source file creates a new FrontendAction, and with it, 
the developer needs a new instance of Rewriter.

While LibTooling intends most of the issues mentioned earlier, 
they are not as quickly comprehendible as the rest of the framework. 
Templates, the language feature of C++, further complicate the matter. 
In Clang AST, multiple types derived from a template might share some nodes. 
Having multiple parent nodes is also not uncommon for template types. 
Thankfully, templates are rarely used. 
A more common threat, macros, has a similar effect. 
Modifying a source code containing macros and comments results in 
losing both.

Doing source-to-source transformation is often accompanied by 
inserting instrumentation code. 
By performing so-called cross-checking, one can make sure that 
the transformation behaves as intended. 
Cross-checking works by inserting code with the same behavior 
into the original and the transformed source code.  
This insertion can be done in a sophisticated manner using the AST. 
If, for example, the transformation alters calls to functions 
in the code, the instrumentation code should be inserted inside the 
function's bodyâ€”that way, the developer can check whether 
the transformation had its intended result.
Cross-checking is a safe way of ensuring source-to-source 
transformations work as intended. 
While they might be excessive for small refactorings, 
they are beneficial when debugging source-to-source 
transformations of larger scales, such as translating 
one language's source code to another's.
